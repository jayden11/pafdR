[
["index.html", "Processing and Analyzing Financial Data with R Welcome!", " Processing and Analyzing Financial Data with R Marcelo S. Perlin (marcelo.perlin@ufrgs.br) 2017-04-29 Welcome! Welcome to the book site of Processing and Analyzing Financial Data with R. Here you can find the full online content of the book. The book is also available as an ebook and print (hardcover). If you liked the material and are using the book, please consider purchasing it. As an author, I certainly appreciate the gesture and will take it as a motivating factor for future editions. This book introduces the reader to the use of R and RStudio as a platform for processing and analyzing financial data. The book covers all necessary knowledge for using R, from its installation in your computer to the organization and development of scripts. For every chapter, the book presents practical and replicable examples of R code, providing context and facilitating the learning process. Based on the material, the reader will learn how to download financial data from local files or the Internet, represent and process it using native objects in R, and create tables and figures to report the results in a technical document. The book is organized based on the author’s practical experience in scientific research and includes instructions for using the best R packages for each purpose, such as xtable and texreg for reporting tables, dplyr in data processing, and ggplot2 in creating figures. After presenting the capabilities of R in processing financial data, the last chapter presents three complete and reproducible examples of research in Finance. This book is recommended for postgraduate researchers and students interested in learning how to use R. No prior knowledge of programming or finance is required to take advantage of this book. After finishing, the reader will have enough knowledge to develop their own scripts autonomously, producing academic documents or data analysis for public and private institutions. "],
["preface.html", "Preface", " Preface Since you are reading this book, you are likely a financial analyst looking for alternative and more efficient ways to process your financial data, an undergraduate or graduate student in its first steps regarding scientific research, or an experienced researcher, looking for new tools to use in your work. In all cases, this book is for you. The objective of this work is to introduce the reader to the use of R as a computational tool for data analysis, with a special emphasis on empirical research in finance. With this book, you will learn how to load financial data into R, manipulate the information in a way that makes sense to your problem and build the content of a report with tables and figures. The material in this book started as class slides from my work as a teacher and researcher. By watching students learning and using R in the classroom, I frequently observe the positive impact this knowledge has in their careers. They can do complex data tasks with their computer, providing better and more comprehensive analysis to help the decision making process in their organizations. They spend less time doing repetitive and soul-crushing data chores and more time thinking about their analysis. This book attempts to go beyond the classroom and reach a bigger and more diversified audience. Another motivation for writing this book is my personal experience using code from other researchers. Usually, the code is not well-organized, lacks clarity, and, possibly, only works in the computer of its author! After being constantly frustrated, I realized the work needed to figure out the code of other researchers would take more time than writing the procedure myself. These cases hurt the development of science, as one of it basic principles is the reproducibility of experiments. For the case of a computer intensive field, such as empirical finance, the underlying research code should run without effort in other people’s computers. As researchers are expected to be good writers, it should also be expected that their code is in a proper format and readable by other people. Unfortunately, this is not usual. With this book, I will tackle this problem by presenting a code structure focused on scientific reproducibility, organization, and usability. In this book, we will not work on the advanced uses of R. The content will be limited to simple and practical examples of using the software to construct research focused on the area of Finance. One of the challenges of writing this book was defining the boundary between introductory and advanced material. Wherever possible, I gradually dosed the level of complexity. For readers interested in learning advanced features of the program and its inner workings, I suggest the work of Venables et al. (2004), Teetor (2011) and Wickham (2014). The book includes the following chapters: Chapter 1 - Introduction - Introduces the reader to the use of R as a programming platform designed to solve data related problems in finance. In this chapter, we will present the steps for installing the required software and the reasons why you should adopt it. Chapter 2 - Basic Operations - Discusses the basic commands in R and the features of RStudio. These are common operations and form the groundwork of using the software. It includes the topics of objects creation, international and local format, using auto-complete features of RStudio and many more. Chapter 3 - Basic Classes - Presents the most used classes of objects in R, including numeric types, factors, text and Dates. In this chapter you’ll learn how to use the basic classes to represent information about your data problem and the possible manipulations for each type of object. Chapter 4 - Data Structure Classes - Discusses the use of more advanced objects that structure the basic classes in an efficient way. It includes lists, matrices and dataframes. Most importantly, we will discuss the use of dataframes, a powerful and flexible object that will represent our whole dataset. Chapter 5 - Financial Data and Common Operations - In this chapter we will discuss the origin and content of the most used types of financial data, including data from financial markets, project assessment and financial statements. Common operations with this data, such as the calculation of returns, are also discussed. Chapter 6 - Importing and Exporting Data - This chapter presents the most common functions for importing and exporting data. A special emphasis is given to importing financial datasets from the Internet using specialized packages. Chapter 7 - Programming and Data Analysis with R - In this chapter we will learn the programming capabilities of R, including the use of functions, loops and conditional statements. A special emphasis is given for using R’s functions in the manipulation of financial datasets. Package dplyr is also presented as an alternative and efficient way of processing financial information. Chapter 8 - Creating and Saving Figures with ggplot2 - Here we will learn to use functions from package ggplot2 to create visualizations of our financial datasets, including the most common cases in finance, time series and statistical plots. Chapter 9 - Financial Econometrics with R - Presents the use of six common econometric models for financial research. It includes linear, GLM, panel data, Arima, Garch and markov switching models. For each type of model, we will learn how to simulate, estimate and forecast. Whenever appropriate, we will also learn to use R in the calculation of related statistical tests. Chapter 10 - Writing Research Scripts - Discusses the structure of a research script, including stages and folder organization. Three replicable examples of financial research scripts are presented. This includes an analysis of the performance of international stock indices, a study for the performance of a forecasting algorithm and an analysis of high frequency trade data. I’m a fan of open source code. All the code used in the book, including examples separated by chapters, is available on the Internet. I also maintain a personal website with details of my work as a researcher and a blog (R and Finance), where I write about the use of R on specific problems among other things. All web addresses are given below: Book site: https://sites.google.com/view/pmfdr/home Personal page: https://sites.google.com/site/marceloperlin/ Blog R and Finance: https://msperlin.github.io/ A suggestion, before you read the book, go to the book website and look at the related links page. There, you will find all internet addresses highlighted in the text, including the links for the installation of R and RStudio. I hope you enjoy this book and find it useful. Good reading! Marcelo S. Perlin References "],
["introduction.html", "Chapter 1 Introduction 1.1 What is R 1.2 Why Choose R 1.3 What Can You Do With R and RStudio? 1.4 Installing R and RStudio 1.5 Resources in the Web 1.6 Structure and Organization", " Chapter 1 Introduction In the digital era, information is abundant and cheap. From the ever-changing price of financial contracts to the unstructured data of social media websites, the high volume of information we observe in the workplace creates a strong need for data analysis. A company or organization benefits immensely when it can create a bridge between raw information from its environment and making strategic decisions. Undoubtedly, this is a prolific time for professionals skilled in using the right tools for acquiring, storing, and analysing data. In particular, datasets related to Economy and Finance are widely available to the public. International and local institutions, such as central banks, national research agencies, financial exchanges, and many others, provide their data publicly, either by legal obligation or to foment research. Whether you are looking into statistics for a particular country or a company, most information is just a couple of clicks away. By analysing this information efficiently, you’ll be able to offer valuable insights to your team. Technological advancements were accompanied by a decrease in computational cost. Today, home computers can process massive amounts of data in a short while, making it accessible to anyone. The methods applied to the data have also advanced in complexity. While in the past, a simple spreadsheet can do the job; today, the situation is different. For areas of knowledge with practical applications, such as Economy and Finance, it is expected that a graduate student or a data analyst has learned at least one programming language that allows him to do his work in an efficient manner. Learning how to program is becoming a requisite for the job market. In this setup, the role of R, a programming language aimed to solve computational problems involving data analysis, shines. In the following sections, we will explain what R is and why you should use it . 1.1 What is R R is a programming language specially designed to resolve statistical problems and allow the graphical display of data. R is a GNU version of S, a programming language originally created in Bell Laboratories (formerly AT&amp;T, now Lucent Technologies). The base code of R was developed by two academics, Ross Ihaka and Robert Gentleman, resulting in the programming platform we have today. For anyone curious about the name, the letter R was chosen due to the common first letter of the name of their creators. Today, R is almost synonymous to data analysis, with a large user base and defined packages that extend its use. It is likely that researchers from various fields, from Economics to Biology, find in R significant preexisting code that facilitates their analysis. In the business side, large and established companies, such as Google and Microsoft, already adopted R as the internal language for data analysis. R is maintained by R Foundation and the R Consortium, a collective effort to fund projects for extending the programming language. 1.2 Why Choose R Learning a new programming language requires a lot of time and effort. Perhaps you’re wondering why you should opt for R and invest time in learning it. Here are the main arguments. First, R is a mature, stable platform, continuously supported and intensively used in the industry. When choosing R, you will have the computational background not only for an academic career in scientific research, but also to work as a data analyst in private organizations. If you are a student, learning R will create more options for your future career. Also, the strong support from the community means it very unlikely the R platform will ever fade away or be substituted for something else. Depending on your career choices, R might be the only programming language you ever need to learn. Learning R is easy. My experience in teaching R allows me to say students, even those with no programming experience, have no problem learning the language and using it to create their own code. The language is intuitive and certain rules and functions can be extended to different cases. For example, function print is used to show the contents of an object on the screen. You can use it for any kind of object as it adapts to the class of the object. So, by learning it one time, you’ll be able to apply it in many different scenarios. Once you understand how the program works, it is easy to discover new features starting from a previous logic. This generic notation facilitates the learning process. The engine of R and the interface of RStudio creates a highly productive environment. The graphical interface provided by RStudio facilitates the use of R and increases productivity. By combining both, the user has at his disposal many tools that facilitate the use of the platform. R is compatible with different operating systems and it can interface with different programming languages. If you need to use a code in other programming language, such as C++, Python, Julia, it is easy to integrate it with R. Therefore, the user is not restricted to a single language and can use features and functions from other platforms. The possibility of using other programming languages within R is part of its functionalities. R is free! The main software and all its packages are free to use. For most packages, the user’s license gives you freedom to use and modify the code freely in your work. This supports the adoption of the R language in a business environment, where obtaining individual and collective licenses of commercial software can cause a high financial cost. Not surprisingly, R is used in a large number of companies. 1.3 What Can You Do With R and RStudio? R is a fairly complete programming language and any computational problem can be solved based on it. Given the adoption of R for different areas of knowledge, the list is extensive. With finance, I highlight the following possibilities: Import, export, process, and store financial data based on local files or the internet; Substitute and improve data intensive tasks from spreadsheet like software; Develop routines for managing and controlling investment portfolios and executing financial orders; Implementation of various possibilities of empirical research through statistical tools, such as econometric models and hypothesis testing; Create dynamic websites with the Shiny package, allowing anyone in the world to use a financial tool created by you; Create an automated process of developing technical financial reports with package knitr; Write a technical book with bookdown; Write and publish a blog about finance with blogdown; Besides the previously highlighted uses, public access to packages developed by users further expands these capabilities. The CRAN website offers a Task Views panel for the topic of Finance. On this page, you can find the main packages available to perform specific operations in Finance. This includes importing financial data from the internet, estimating econometric model, calculation of different risk estimates, among many other possibilities. Reading this page and the knowledge of these packages is essential for those who intend to work in Finance. It is worth noting, however, this list contains only the main items. The complete list of packages related to Finance is much larger than shown in Task Views. The link to the CRAN site is available on the book page. In this book, we will cover many packages from the task view in finance. 1.4 Installing R and RStudio Before going further, let’s install the required software on your computer. R is installed on your operating system like any other program. The most direct and practical way to install it is to go to R website and click the Download link in the left side of the page, as shown in Figure 1.1. Figure 1.1: Initial page for downloading R The next screen gives you a choice of mirror to download the installation files. The CRAN repository (R Comprehensive Archive network) is mirrored in various parts of the world to improve the access speed. You can choose one of the links from the nearest location to you. If undecided, just select the mirror 0-Cloud, as show in Figure 1.2. Figure 1.2: Choosing the CRAN mirror The next step involves selecting your operating system. This is likely to be Windows. Due to the greater popularity of this platform, from now on, we will focus on installing R in Windows. The instructions for installing R in other operating systems can be easily found online. Regardless of the underlying platform, using R is about the same. There are a few exceptions, especially when R interacts with the file system. In the content of the book, special care was taken to choose functions that work the same way in different operating systems. A few exceptions are highlighted throughout the book. So, even if you are using Mac or Linux, you can take full advantage of the material presented here . Figure 1.3: Choosing the operating system After clicking the link Download R for Windows, as in Figure 1.3, the next screen will show the following download options: base, contrib, old.contrib and RTools. Among the download options, the first (base), should be selected. It contains the basic installation of R in Windows. If the user is interested in creating and distributing their own R packages, it is necessary to install RTools. For most users, however, this should not be the case, so I suggest ignoring this program. The links to contrib and old.contrib relate to files for the current and old releases of R packages. You should not worry about it for now. We will discuss the use of packages in the next chapter. Figure 1.4: Installation options After clicking the link base, the next screen will show the link to the download of the R installation file (Figure 1.5). After downloading the file, open it and follow the steps in the installation screen. At this time, no special configuration is required. I suggest keeping all the default choices and simply hit accept in the displayed dialogue screens. After the installation of R, it is strongly recommended to install RStudio, which will be addressed next . Figure 1.5: Downloading R The base installation of R includes its own GUI (graphical user interface) that facilitates the use of the program. However, this native interface has several limitations. RStudio is a software that substitutes the original interface and makes the access to R more practical and efficient. One way to understand this relationship is with an analogy with cars. While R is the engine of the programming language, RStudio is the body and instrument panel, which significantly improve the user experience. Besides presenting a more attractive look, RStudio also adds several features that make the life of a programmer easier, allowing the creation of projects and packages, creation of dynamic documents (Sweave/knitr), among others. As an example, the book you are reading was written in RStudio with package bookdown. The installation of RStudio is simpler than that of R. The files are available in RStudio website, provided in the book site. After accessing the page, click Download RStudio and then Download RStudio Desktop. After that, just select the installation file relative to the operating system on which you will work. This option is probably WINDOWS Vista 7/8/10. Note that, as well as R, RStudio is also available for alternative platforms. I emphasize that using RStudio is not essential to develop programs in R. Other interface software are available and can be used. However, in my experience, RStudio is the interface that offers the widest range of features for the language and is widely used, which justifies its choice. 1.5 Resources in the Web The R community is vivid and engaging. There are many authors, such as myself, that constantly release material about R in their blogs and are happy to discuss it. It includes package announcements, posts about data analysis in real life, curiosities, rants and tutorials. R-Bloggers is a website that aggregates these blogs in a single place, making it easier for anyone to access and participate. I strongly recommend to sign up for the R-Bloggers feed in RSS, Facebook or Twitter. Not only you’ll be informed of what is happening in the R community, but also learn a lot by reading other people code and articles. Learning and using R can be a social experience. Several conferences and user-groups are available in many countries. You can find the complete list in this link. I also suggest looking for local groups in Facebook. These may not be registered in the previous link. 1.6 Structure and Organization This book presents a practical approach to the use of R in finance, accompanied by R code, which will show and illustrate the functionality of the program. To get the most out of this book, I suggest you first seek to understand the code shown, and only then, try using it on your own computer. Learning to program in a new language is like learning a foreign spoken language: the use in day-to-day problems is imperative to create fluency. All the code and data used in this book is available in the book webpage. I suggest you test the code on your computer and play with it, modifying the examples and checking the effect of changes in the outputs. Whenever you have a computational problem, try using R for solving it. You’ll stumble and make mistakes at first. But I guarantee that, soon enough, you’ll be able to write complex data tasks effortlessly. Throughout the book, every demonstration of code will have two parts: the R code and its output. The output is nothing more than the result of the commands in the program screen. All inputs and outputs code will be marked in the text with a special format. See the following example: # create a list x &lt;- list(&#39;abc&#39;, 1:5, &#39;dec&#39;) # print list print(x) ## [[1]] ## [1] &quot;abc&quot; ## ## [[2]] ## [1] 1 2 3 4 5 ## ## [[3]] ## [1] &quot;dec&quot; For the previous chunk of code, lines x &lt;- list('abc', 1:5, 'dec') and print(x) are actual commands given to R. The program output is the on-screen presentation of the contents of object x with the predecessor symbol ##. This symbol is used for any code output. Notice also that inline comments are set with the symbol #. Anything in the right side of # is not evaluated by R. These comments serve as written notes about the code. Code can also be spatially organized using new lines. This is a common procedure around arguments of functions. The next chunk of code is equivalent to the previous, and will run the exact same way. Notice how we used a new line to vertically align the arguments of function list. You’ll soon see that, throughout the book, this type of vertical alignment is constantly used. # create a list x &lt;- list(&#39;abc&#39;, 1:5, &#39;dec&#39;) # print list print(x) ## [[1]] ## [1] &quot;abc&quot; ## ## [[2]] ## [1] 1 2 3 4 5 ## ## [[3]] ## [1] &quot;dec&quot; The code also follows a well-defined structure. One decision in writing computer code is how to name objects and how to structure it. It is recommended to follow a clear pattern, so it is easy to maintain over time and be used and understood by others. For this book, a mixture of the author’s personal choices with the coding style suggested by Google (link on the book website) was used. The reader, however, may choose the structure he finds more efficient and aesthetically pleasing. Like many things in life, this is a choice. "],
["basic-operations-in-r.html", "Chapter 2 Basic Operations in R 2.1 Working With R 2.2 Objects in R 2.3 International and Local Formats 2.4 Types of Files in R 2.5 Explaining the RStudio Screen 2.6 Running Scripts from RStudio 2.7 Testing and Debugging Code 2.8 Creating Simple Objects 2.9 Creating Vectors 2.10 Knowing Your Environment 2.11 Displaying and Formatting Output 2.12 Finding the Size of Objects 2.13 Selecting the Elements of an Atomic Vector 2.14 Removing Objects from the Memory 2.15 Displaying and Setting the Working Directory 2.16 Cancelling Code Execution 2.17 Code Comments 2.18 Looking for Help 2.19 R Packages 2.20 Using Code Completion with tab 2.21 Interacting with Files and the Operating System", " Chapter 2 Basic Operations in R Before you start developing your code, you need to understand how to work with R and RStudio. This includes work patterns, language components, basic commands and RStudio shortcuts. Understanding the software and how to take advantage of the platform is essential for the development of data-based research scripts. This is the main chapter for those who are not familiar with R or other programming languages. In this section, we will go through the initial steps from the point of view of someone who has never worked with R and possibly never had contact with another programming language. Those already familiar with the program will not find novel information here and therefore, I suggest you skip to the next section. It is recommended, however, that you at least check the topics discussed here so that you can confirm your knowledge about the features of the program. 2.1 Working With R The greatest difficulty a new user experiences when starting to develop routines in R is the format of work. Our interaction with computers has been simplified over the years and we are currently comfortable with the point&amp;click format. That is, if you want to perform some operation on the computer, just point the mouse to the specific location on the screen and click the button that performs the operation. Visual cues and a series of steps in this direction allows the execution of complex tasks. But, be aware that this form of interaction is just one layer above what actually happens on the computer. Behind all these clicks, there is a command being executed. Any common task such as opening a pdf file, a spreadsheet document, directing a browser to a web page has an underlying call to a command. This command was created by the program developer to run within your operating system. While this visual and motor interaction format has its benefits in facilitating and popularizing the use of computers, it is not flexible and effective when working with computational procedures. By knowing the commands available to the user, it is possible to create a file containing several instructions in sequence and, in the future, simply request that the computer execute this file using the recorded procedures. There is no need to do a “scripted” point&amp;click operation. You need to spend some time creating the program but, in the future, it will always execute the recorded procedure in the same way. In the medium and long term, there is a significant gain in productivity between the use of a script (sequence of commands) and a point&amp;click type of interface. Going further, the risk of human error in executing the procedure is almost nil because the commands and their sequence are recorded in the text file and will always be executed in the same way. This is one of the main reasons why programming languages are popular in science. All steps of data based research can be replicated. In the use of R, the ideal format of work is to merge the use of the mouse with commands. R and RStudio have some functionality with the mouse, but their capacity is optimized when we perform operations using code. When a group of commands is performed in a smart way, we have an R script that should preferably produce something important to us at the end of its execution. In Finance, this can be the updated value of an investment, the calculation of the risk of a portfolio, the historical performance of an investment strategy, the result of an academic research, among many other possibilities. Like other software, R allows us to import data and export files. We can use code to import a dataset stored in a local file (or the web), do an analysis of this data and save the results to later import it into a technical report. In fact, we can use RStudio to write a dynamic report, where code and content are integrated, using knitr and Sweave (Leisch 2002). For example, the book you’re reading was written using knitr and the bookdown package (Xie 2016). The book is compiled with the execution of the R codes and their outputs are recorded in the scope of the text. All figures and data tasks in the book can be updated with the execution of a simple command. Needless to say that by using the capabilities of R and RStudio, you will work smarter and faster. 2.2 Objects in R In R, everything is an object, and each type of object has its properties. For example, the daily market closing prices of a stock can be represented as a numerical vector, where each element is a price recorded at the end of a trading day. Dates and times related to these prices can be represented as text (string) or one of the datetime classes. Finally, we can represent the price data and the dates together by storing them in a single object of type dataframe, which is nothing more than a table with rows and columns. These objects are part of the R ecosystem, and it is through their manipulation that we take full advantage of the software. While we represent data as objects in R, a special type is a function, which stores a pre-established procedure that is available to the user. R has an extremely large number of functions, which enable the user to perform a wide range of operations. For example, the basic commands of R, available in the package base, adds up to a total of 1217 functions. Each function has its own name and a programmer can write their own functions. For example, the mean function is a procedure that calculates the average values of a vector. If we wanted to calculate the average value of the sequence 1, 2, 3, 4, 5, simply insert the following command in the prompt (left bottom of RStudio) and press enter: mean(1:5, na.rm = TRUE) ## [1] 3 The : symbol used above creates a sequence starting at 1 and ending at 5 (more details about this operator in a later section). Note that the mean function is used with start and end parentheses. These parentheses serve to highlight the entries (inputs), that is, the information sent to the function to produce something. Note that each entry is separated by a comma, as in MyFct(input1, input2, input3, ...). We also set option na.rm = TRUE. This is a specific directive for the mean function to ignore elements of type NA (not available), if they exist. This specific type of object will also be discussed in a future chapter. Functions are at the heart of R and we will dedicate a large part of this book to them. You can use the available functions or write your own. You can also publish your functions and let other people use your code. In a later chapter, we will learn how to use functions to do data analysis in an efficient way. 2.3 International and Local Formats Before beginning to explain the use of R and RStudio, it is important to highlight some rules of formatting numbers, Latin characters and date formats. decimal: Following an international notation, the decimal point in R is defined by the period symbol (.), as in 2.5 and not comma, as in 2,5. In some countries, this might not be the case. This difference can create a lot of confusion and errors at the beginning. Some software, such as Microsoft Excel, does the conversion automatically when the data is imported. This, however, is generally an exception. As a general rule of using R, only use commas to separate the inputs of a function. Under no circumstances should the comma symbol be used as the decimal point separator. Always give priority to the international format because it will be compatible with the vast majority of data. Other researchers may experience some difficulty in understanding your code if you use your local notation for the decimal. Latin characters: Due to its international standard, R has problems understanding Latin characters, such as the cedilla and accents. If you can avoid it, do not use these characters in the names of your variables or files. In character objects (text), you can use them without problems as long as the encoding is correctly specified (e.g. UTF-8, Latin1). Given that, it is recommended that the R code be written in the English language. This automatically eliminates the use of Latin characters and facilitates the usability of the code by people outside of your country. date format: Dates in R are formatted according to the YYYY-MM-DD pattern, where YYYY is the year in four numbers, MM is the month and DD is the day. An example is 2017-04-29. This may not be the case in your country. When importing local datasets, make sure that the dates are in this format or do a conversion. Again, while you can work with your local format of dates in R, it is best advised to use the international notation. The conversion between one format and another is quite easy and will be presented in a future chapter. If you want to learn more about your local format in R, use the following command by typing it in the prompt and pressing enter: Sys.localeconv() ## decimal_point thousands_sep grouping ## &quot;.&quot; &quot;&quot; &quot;&quot; ## int_curr_symbol currency_symbol mon_decimal_point ## &quot;BRL&quot; &quot;R$&quot; &quot;,&quot; ## mon_thousands_sep mon_grouping positive_sign ## &quot;.&quot; &quot;\\003&quot; &quot;&quot; ## negative_sign int_frac_digits frac_digits ## &quot;-&quot; &quot;2&quot; &quot;2&quot; ## p_cs_precedes p_sep_by_space n_cs_precedes ## &quot;1&quot; &quot;1&quot; &quot;1&quot; ## n_sep_by_space p_sign_posn n_sign_posn ## &quot;1&quot; &quot;3&quot; &quot;3&quot; The output of Sys.localeconv() shows how R interprets decimal points and the thousands separator, among other things. As you can see from the previous output, this book was compiled using the Brazilian notation for currency but uses the dot point for decimals. As mentioned before, it is good policy to follow international notation, especially for the decimal point. If necessary, you can change your local format to the US/international notation using the following command. Sys.setlocale(&quot;LC_ALL&quot;, &quot;English&quot;) A note, however, is that you’ll need to run this command every time that R starts or incorporate it in the initialization of the software. 2.4 Types of Files in R Like any other programming platform, R has a file ecosystem and each type of file has a different purpose. In the vast majority of cases, however, the work will focus mostly on two types: .R and .RData files. Next, I provide a description of various file extensions. The items in the list are ordered by importance. Note that we omit graphic files such as .png, .jpg, .gif and data storage files (.csv, .xlsx, ..) among others, as they are not exclusive to R. Files with the extension .R : text files containing several instructions for R. These are the files that will contain the sequence of commands that configures the main script and subroutines of the data research. Examples: My-Research.R, My_Functions.R. Files with extension .RData: files that store data in R native format. These files are used to save (write) objects created in different sessions. For example, you can use a .RData file to save a table after processing and cleaning up the raw database. This file can be later loaded for a subsequent analysis. Examples: My_data.RData, Research_Results.RData. Files with extension .Rmd, .md and .Rnw: represent files used for editing dynamic documents related to the Rmarkdown and markdown formats. The use of these files allows the creation of documents where text and code output are integrated. This is an advanced topic and will not be covered in this book. For those interested, I suggest reading Baumer et al. (2014) and a tutorial at this link. Example: My_Report.Rmd. Files with extension .Rproj: contain files for editing projects in RStudio, such as a new package, a shiny application or a book. This is also an advanced topic and will not be dealt with here. While you can use the functionalities of RStudio projects to write R scripts, it is not a necessity. For those interested in learning more about this functionality, I suggest the RStudio manual. Example: MyProject.Rproj. 2.5 Explaining the RStudio Screen After installing the two programs, R and RStudio, open RStudio by double clicking its icon. It should be noted that R also has an interface program and this often causes confusion. You should find the correct shortcut for RStudio by going through your software folders. In Windows, you can search for RStudio using the Start button. After opening RStudio, the resulting window should look like Figure 2.1. Figure 2.1: The RStudio screen Note that RStudio automatically detected the installation of R and initialized your screen on the left side. If you do not see something like this on the screen of RStudio: R version 3.3.3 (2017-03-06) -- &quot;Another Canoe&quot; Copyright (C) 2017 The R Foundation for Statistical Computing Platform: x86_64-w64-mingw32/x64 (64-bit) R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under certain conditions. Type &#39;license()&#39; or &#39;licence()&#39; for distribution details. R is a collaborative project with many contributors. Type &#39;contributors()&#39; for more information and &#39;citation()&#39; on how to cite R or R packages in publications. Type &#39;demo()&#39; for some demos, &#39;help()&#39; for on-line help, or &#39;help.start()&#39; for an HTML browser interface to help. Type &#39;q()&#39; to quit R. then R was not installed correctly. Repeat the installation steps in the previous chapter and confirm the startup message on the lower left side of RStudio. As a first exercise, click file, New File, and R Script. A text editor should appear on the left side of the screen. It is there that we will enter our commands, which are executed from top to bottom, in the same direction that we normally read text. A side note, all .R files created in RStudio are just text files and can be edited in other editors as well. It is not uncommon for experienced programmers to use a specific software to write code and another to run it. The resulting screen should look like the following: Figure 2.2: Explaining the RStudio screen The main items/panels of the RStudio screen in Figure 2.2 are: Script Editor: located on the left side and above the screen. This panel is used to write scripts and functions; R prompt: located on the left side and below the script editor. It displays the prompt of R, which can also be used to give commands to R. The main function of the prompt is to test code and display the results of the commands entered in the script editor; Environment: located on the top-right of the screen. Shows all objects, including variables and functions currently available to the user. Also note a History panel, which shows the history of the commands previously executed by the user; Panel Packages: shows the packages installed and loaded by R. Here you have four tabs: Files, to load and view system files; Plots, to view pictures; Help to access the help system and Viewer to display dynamic and interactive results, such as a web page. As an introductory exercise, let’s initialize two objects in R. Inside the prompt (lower left side), insert the following commands and press enter at the end of each. The &lt;- symbol is nothing more than the result of joining &lt; (less than) with the - (minus sign). The ' symbol represents a single quotation mark and, in the computer keyboard, it is found under the escape (esc) key. # set x x &lt;- 1 # set y y &lt;- &#39;My humble text&#39; If done correctly, notice that two objects appeared in the environment panel, one called x with a value of 1, and another called y with the text content &quot;My humble text&quot;. Notice how we used specific symbols to define objects x and y. The use of double quotes (&quot; &quot;) or single quotes (' ') defines objects of the class character. Numbers are defined by the value itself. As will be discussed later, each object in R has a class and each class has a different behaviour. After sending the previous commands to R, the history tab has been updated. Now, let’s show the values of x on the screen. To do this, type the following command: # print contents of x print(x) ## [1] 1 The print function is one of the main functions for displaying values in the prompt of R. The text displayed as [1] indicates the index of the first line number. To verify this, enter the following command, which will show a lengthy sequence of numbers on the screen: # print a sequence print(50:100) ## [1] 50 51 52 53 54 55 56 57 58 59 60 61 62 63 ## [15] 64 65 66 67 68 69 70 71 72 73 74 75 76 77 ## [29] 78 79 80 81 82 83 84 85 86 87 88 89 90 91 ## [43] 92 93 94 95 96 97 98 99 100 In this case, we use the : symbol in 50:100 to create a sequence starting at 50 and ending at 100. Note that on the left side of each line, we have the values 1, 15, and 29. These represent the index of the first element presented in the line. For example, the fifteenth element of 50:100 is 64. 2.6 Running Scripts from RStudio Now, let’s combine all the previously typed codes into a single file by copying and pasting all commands into the editor’s screen (upper left side). The result looks like Figure 2.3. Figure 2.3: Example of a R script After pasting all the commands in the editor, save the .R file to a personal folder where you have read and write permissions. One possibility is to save it in the My Documents folder with a name like 'MyFirstRScript.R'. This saved file, which at the moment does nothing special, records the steps of a simple algorithm that creates several objects and shows their content. In the future, this file can take an expressive size by containing all stages of the data analysis such as importing data, cleaning it, performing the data analysis and exporting tables and figures. In RStudio, there are some predefined and time-saving shortcuts for running code from the editor. To execute an entire script, simply press control + shift + s. This is the source command. With RStudio open, I suggest testing this key combination and checking how the code saved in a .R file is executed. The output of the script is shown in the prompt of R. The result in RStudio should look like Figure 2.4. Figure 2.4: Example of a R script after execution Another very useful command is code execution by the lines. In this case, the whole file is not executed, but only the line where the cursor is located. For that, just press control + enter. This shortcut is very useful in developing scripts because it allows each line of the code to be tested before running the entire program. As an example of usage, point the cursor to the print(x) line and press control + enter. As you will notice, only the line print(x) was executed. Therefore, before running the whole script, you can test it line by line and check for possible errors. Next, I highlight these and other RStudio shortcuts, which are also very useful. control + shift + s: executes (source) the current RStudio file; control + shift + enter: executes the current file with echo, showing the commands on the prompt; control + enter: executes the selected line, showing on-screen commands; control + shift + b: executes the codes from the beginning of the file to the current line where the cursor is; control + shift + e: executes the codes of the lines where the cursor is until the end of the file. My suggestion is to use these shortcuts from day one. They greatly facilitate the use of the program. For those who like to use the mouse, an alternate way to execute code is to click the source button in the upper-right corner of the text editor. If you want to set your own shortcuts in RStudio, go to option, “Tools” and “Modify Keyboard Shortcuts”. One suggestion here is to set the source command to F5, which is used by several other software as an “execute” shortcut. If you want to run code in a .R file within another .R file, you can use the source command. For example, imagine that you have a main script with your data analysis and another script that performs some support operation such as importing data to R. These operations have been dismembered as a way of organizing the code. To run the support script, just call it with function source in the main script, as in the following code: # execute import script source(&#39;import-data.R&#39;) In this case, all code in import-data.R will be executed. This is equivalent to manually opening file import-data.R and hitting control + shift + s. 2.7 Testing and Debugging Code The development of code follows a cycle. At first, you will write a command line on a script, try it using control + enter and check the output. A new line of code is written once the previous line worked as expected. A moving cycle is clear, writing code is followed by line execution, followed by result checking, modify and repeat if necessary. This is a normal process. You need to make sure that every line of code is correctly specified before moving to the next one. When you are trying to find an error in a preexisting script, R offers some tools for controlling and assessing its execution. This is specially useful when you have a long and complicated script. The simplest and easiest tool that R and RStudio offers is code breakpoint. In RStudio, you can click in the left side of the script editor and a red circle will appear, as in Figure 2.5. Figure 2.5: Example of breakpoint in an R script This red circle indicate a code breakpoint that will force the code to stop at that line. You can use it to test existing code and check its objects at a certain part of the execution. When the execution hits the breakpoint, the prompt will change to Browse[1]&gt; and you’ll be able to try new code of verify the content of the objects. From the Console, you have the option to continue the execution to the next breakpoint or stop it. The same result can be achieved using function browser. Have a look: # set x x &lt;- 1 # set y browser() y &lt;- &#39;My humble text&#39; # print contents of x print(x) The practical result is the same as using RStudio’s red circle, but it gives you more control for the case of several commands in the same line. 2.8 Creating Simple Objects One of the most basic and most used commands in R is the creation of objects. As shown in previous sections, you can define an object using the &lt;- command, which is verbally translated to assign. For example, consider the following code: # set x x &lt;- 123 # set x, y and z in one line my.x &lt;- 1 ; my.x &lt;- 2; my.z &lt;- 3 We can read this code as the value 123 is assigned to x. The direction of the arrow defines where the value is stored. For example, using 123 -&gt; x also works, although this is not recommended as the code becomes less readable. Also notice that you can create objects within the same line by separating the commands using a semi-colon. The use of an arrow symbol &lt;- for object definition is specific to R. The reason for this choice was that, at the time of conception of the S language, keyboards with a key that directly defined the arrow symbol were available and used. This means that the programmer only had to hit one key in the keyboard in order to set the arrow symbol. Modern keyboards, however, do not have this format any more. If you find it troublesome to use this symbol, you can use shortcuts as well. In Windows, the shortcut for the the symbol &lt;- is alt plus -. You can also use the = symbol to define objects such as in x = 123, but the use of = with this specific purpose is not recommended. The symbol of equality has a special use within the definition of function arguments. This case will be better explained and demonstrated in future section. The name of the object is important in R. With the exception of very specific cases, the user can name objects as he likes. This freedom, however, can be a problem. It is desirable to always give short names that make sense to the content of the script and which are simple to understand. This facilitates the understanding of the code by other users and is part of the suggested set of rules for structuring code. Note that all objects created in this book have nomenclature in English and specific formatting, where the white space between nouns are replaced by a dot, as in my.x &lt;- 1 and name.of.file &lt;- 'my_file.csv'. R executes the code looking for objects available in the environment, including functions. Be aware that R is case sensitive, that is, object m is different than M. If we try to access an object that does not exist, R will return an error message and stop the execution. Have a look: print(z) ## Error in print(z): object &#39;z&#39; not found The error occurred because object z does not exist in the current environment. If we create a variable z as z &lt;- 321 and repeat the command print(z), we will not have the same error message. 2.9 Creating Vectors In the previous examples, we have created simple objects such as x &lt;- 1 and x &lt;- 'abc'. While this is sufficient to demonstrate the basic commands in R, in practice, such commands are very limited. A real problem of data analysis will certainly have a greater volume of information. One of the most used procedures in R is the creation of atomic vectors. These are objects that can have several elements. All elements of an atomic vector must have the same class, which justifies its atomic property. An example would be the representation of a series of daily stock prices as an atomic vector of the class numeric. Once you have a vector, you can manipulate it anyway you want. Atomic vectors are created in R using the c command, which comes from the verb combine. For example, if we wanted to combine the values 1, 2 and 3 in one object, we could do it with the following command: # create numeric atomic vector x &lt;- c(1,2,3) # print it print(x) ## [1] 1 2 3 This command works the same way for any other class of object, such as character: # create character atomic vector y &lt;- c(&#39;text 1&#39;, &#39;text 2&#39;, &#39;text 3&#39;, &#39;text 4&#39;) # print it print(y) ## [1] &quot;text 1&quot; &quot;text 2&quot; &quot;text 3&quot; &quot;text 4&quot; The only restriction on the use of the c command is that all elements must have the same class. If we insert data from different classes in a call to c(), R will try to mutate all elements into the same class following its own logic. If the conversion of all elements to a single class is not possible, an error message is returned. Note the following example, where numeric values are set in the first and second element of x and a character in the last element. # a mixed vector x &lt;- c(1, 2, &#39;3&#39;) # print result of forced conversion print(x) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; The values of x are all of type character. The use of class command confirms this result: # print class of x class(x) ## [1] &quot;character&quot; 2.10 Knowing Your Environment After using various commands, further development of the script requires you to understand what objects are available and what is their content. You can find this information simply by looking at the upper right screen of RStudio. However, there is a command that shows the same information in the prompt. In order to know what objects are currently available in R’s memory, you can use command ls. Note the following example: # set some objects x &lt;- 1 y &lt;- 2 z &lt;- 3 # print all objects in the environment print(ls()) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; The objects x, y and z were created and are available in the current working environment. If we had other objects, they would also appear in the output to ls. Notice that object returned from ls is a character vector. To display the content of each object, just enter the names of objects and press enter in the prompt: # print objects by their name x ## [1] 1 y ## [1] 2 z ## [1] 3 Typing the object name on the screen has the same effect as using the print command. In fact, when executing the sole name of a variable in the prompt or script, R internally passes the object to the print function. In R, all objects belong to a class. As previously mentioned, to find the class of an object, simply use the class function. In the following example, x is an object of the class numeric, y is a text (character) object and my.fct is a function object. # set objects x &lt;- 1 y &lt;- &#39;a&#39; my.fct &lt;- function(){} # print their classes print(class(x)) ## [1] &quot;numeric&quot; print(class(y)) ## [1] &quot;character&quot; print(class(my.fct)) ## [1] &quot;function&quot; Another way to learn more about an object is to check their textual representation. Every object in R has a textual representation and we can find it with function str: # print the textual representation of a vector print(str(1:10)) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 ## NULL This function is particularly useful when trying to understand the details of a more complex object, such as a dataframe. We will learn more about using function str for learning the contents of a dataframe in chapter ??. 2.11 Displaying and Formatting Output So far, we saw that you can show the value of an R object on the screen in two ways. You can either enter its name in the prompt or use the print function. Explaining it further, the print function focuses on the presentation of objects and can be customized for any type. For example, if we had an object of a class called MyTable to represent a specific type of table, we could create a function called print.MyTable that would show a table on the screen with a special format for the rows and column names. Function print, therefore, is oriented towards presenting objects and the user can customize it for different classes. The base package, which is automatically initialized with R, contains several print function for various kinds of objects. However, there are other specific functions to display text in the prompt. The main one is cat (concatenate and print). This function takes a text as input, processes it for specific symbols and displays the result on the screen. Function cat is more powerful and customizable than print. For example, if we wanted to show the text, The value of x is equal to 2 on screen using a numerical object, we could do it as follows: # set x x &lt;- 2 # print customized message cat(&#39;The value of x is &#39;, x) ## The value of x is 2 You can also customize the screen output using specific commands. For example, if we wanted to break a line in the screen output, we could do it through the use of the reserved character \\n: # set text with break line my.text &lt;- &#39; First Line,\\n Second line&#39; # print it cat(my.text) ## First Line, ## Second line Note that the use of print would not result in the same effect as this command displays the text as it is, without processing it for specific symbols: print(my.text) ## [1] &quot; First Line,\\n Second line&quot; Another example in the use of specific commands for text is to add a tab space with the symbol \\t. See an example next: # set text with tab my.text &lt;- &#39;A-&gt;\\t&lt;-B&#39; # concatenate and print it! cat(my.text) ## A-&gt; &lt;-B We’ve only scratched the surface on the possible ways to manipulate text output. Other ways to manipulate text output based on specific symbols can be found in the official R manual, available on the book website. 2.11.1 Customizing the Output Another way to customize text output is using specific functions to manipulate objects of the class character. For that, there are two very useful functions: paste and format. Function paste glues a series of objects together. It is a very useful function, and will be used intensely for the rest of the examples in this book. Consider the following example: # set some text objects my.text.1 &lt;- &#39;I am a text&#39; my.text.2 &lt;- &#39;very beautiful&#39; my.text.3 &lt;- &#39;and informative.&#39; # paste all objects together and print cat(paste(my.text.1, my.text.2, my.text.3)) ## I am a text very beautiful and informative. The previous result is not far from what we did in the example with the print function. Note, however, that the paste function adds a space between each text. If we did not want this space, we could use function paste0 as in: # example of paste0 cat(paste0(my.text.1, my.text.2, my.text.3)) ## I am a textvery beautifuland informative. Another very useful possibility with the paste function is to insert a text or symbol between the junction of texts. For example, if we wanted to add a comma (,) between each item to be pasted, we could do this by using the input option sep as follows: # example using the argument sep cat(paste(my.text.1, my.text.2, my.text.3, sep = &#39;, &#39;)) ## I am a text, very beautiful, and informative. If we had an atomic vector with all elements to be glued in an single object, we could achieve the same result using the collapse argument. See an example next. # set character object my.text &lt;-c(&#39;I am a text&#39;, &#39;very beautiful&#39;, &#39;and informative.&#39;) # example of using the collapse argument in paste cat(paste(my.text, collapse = &#39;, &#39;)) ## I am a text, very beautiful, and informative. Going forward, command format is used to format numbers and dates. It is especially useful when we create tables and we want to present the numbers in a visually appealing way. By definition, R presents a set number of digits after the decimal point: # example of decimal points in R cat(1/3) ## 0.3333333 If we wanted only two digits on the screen, we could use the following code: # example of using format on numerical objects cat(format(1/3, digits=2)) ## 0.33 Likewise, if we wanted to use a scientific format in the display, we could do the following: # example of using scientific format cat(format(1/3, scientific=TRUE)) ## 3.333333e-01 Function format has many more options. If you need your numbers to come out in a specific way, have a look at the help manual for this function. It is also a generic function and can be used for many types of objects. 2.12 Finding the Size of Objects In the practice of programming with R, it is very important to know the size of the objects being used. Here, size means the number of individual elements. This information serves not only to assist the programmer in checking possible code errors, but also to know the length of iteration procedures such as loops, which will be treated in a later chapter of this book. In R, the size of an object can be checked with the use of four main functions: length, nrow, ncol and dim. Function length is intended for objects with a single dimension, such as atomic vectors: # create atomic vector x &lt;- c(2,3,3,4,2,1) # get length of x n &lt;- length(x) # display message cat(&#39;The size of x is &#39;, n) ## The size of x is 6 For objects with more than one dimension, such as matrices, use functions nrow, ncol and dim (dimension) to find the number of rows (first dimension) and the number of columns (second dimension). See the difference in usage below. # create a matrix M &lt;- matrix(1:20, nrow = 4, ncol = 5) # print matrix print(M) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 5 9 13 17 ## [2,] 2 6 10 14 18 ## [3,] 3 7 11 15 19 ## [4,] 4 8 12 16 20 # calculate size in different ways my.nrow &lt;- nrow(M) my.ncol &lt;- ncol(M) my.length &lt;- length(M) # display message cat(&#39;The number of lines in M is &#39;, my.nrow) ## The number of lines in M is 4 cat(&#39;The number of columns in M is &#39;, my.ncol) ## The number of columns in M is 5 cat(&#39;The number of elements in M is &#39;, my.length) ## The number of elements in M is 20 The dim function shows the dimension of the object, resulting in a numeric vector as output. This function should be used when the object has more than two dimensions. In practice, however, such cases are rare. An example is given next: # get dimension of M my.dim &lt;- dim(M) # print it print(my.dim) ## [1] 4 5 In the case of objects with more than two dimensions, we can use the array function to create the object and dim to find its size. Have a look in the next example: # create an array with three dimensions my.array &lt;- array(1:9, dim = c(3,3,3)) # print it print(my.array) ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 ## ## , , 3 ## ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 # display its dimensions print(dim(my.array)) ## [1] 3 3 3 An important note here is that the use of the functions, length, nrow, dim and ncol are not intended to discover the number of letters in a text. This is a common mistake. For example, if we had a character type of object and we use the length function, the result would be the following: # set text object my.char &lt;- &#39;abcde&#39; # print result of length print(length(my.char)) ## [1] 1 This occurred because the length function returns the number of elements in an object. In this case, my.char has only one element. To find out the number of characters in the object, we use the nchar function as follows: # find the number of characters in an character object print(nchar(my.char)) ## [1] 5 2.13 Selecting the Elements of an Atomic Vector After creating an atomic vector of a class, it is possible that the user is interested in only one or more elements of it. For example, if we were updating the value of an investment portfolio, our interest in a vector containing stock prices is only for the latest price. All other prices were not relevant to our analysis and therefore could be ignored. The selection of pieces of an atomic vector is called indexing and it is accomplished with the use of square brackets ([ ]). Consider the following example: # set x my.x &lt;- c(1, 5, 4, 3, 2, 7, 3.5, 4.3) If we wanted only the third element of my.x, we use the bracket operator as follows: # get third element of x elem.x &lt;- my.x[3] # print it print(elem.x) ## [1] 4 The procedure of indexing also works with vectors. If we are only interested in the last and penultimate values of my.x, we use the following code: # get last and penultimate value of my.x piece.x.1 &lt;- my.x[ (length(my.x)-1):length(my.x) ] # print it print(piece.x.1) ## [1] 3.5 4.3 A cautionary note. A unique property of the R language is that if a non existing element is accessed, the program returns the value NA (not available). See the next example code, where we attempt to obtain the fourth value of a vector with only three components. # set object my.vec &lt;- c(1,2,3) # print non-existing fourth element print(my.vec[4]) ## [1] NA It is important to know this behaviour because the lack of treatment of these errors can lead to problems that are difficult to identify in more complex code. In other programming languages, attempting to access non-existing elements generally returns an error and cancels the execution of the rest of the code. In the case of R, given that access to non-existent elements does not generate an error or warning message, it is possible that this will create a problem in other parts of the script as NA objects are contagious. That is, anything that interacts with NA will also become NA. The user should pay attention every time that NA values are found unexpectedly. An inspection in the length and indexation of vectors may be required. The use of indices is very useful when you are looking for items of a vector that satisfy some condition. For example, if we wanted to find out all values in my.x that are greater than 3, we could use the following command: # find all values in my.x that are greater than 3 piece.x.2 &lt;- my.x[my.x&gt;3] # print it print(piece.x.2) ## [1] 5.0 4.0 7.0 3.5 4.3 It is also possible to index elements by more than one condition using the logical operators &amp; (is) and | (or). For example, if we wanted the values of my.x greater than 2 and lower than 4, we could use the following command: # find all values of my.x that are greater than 2 and lower then 4 piece.x.3 &lt;- my.x[ (my.x&gt;2) &amp; (my.x&lt;4) ] print(piece.x.3) ## [1] 3.0 3.5 Likewise, if we wanted all items that are lower than 3 or greater than 6, we use: # find all values of my.x that are lower than 3 or higher than 6 piece.x.4 &lt;- my.x[ (my.x&lt;3)|(my.x&gt;6) ] # print it print(piece.x.4) ## [1] 1 2 7 Moreover, logic indexing also works with the interaction of different objects. That is, we can use a logical condition in one object to select items from another: # set my.x and my.y my.x &lt;- c(1,4,6,8,12) my.y &lt;- c(-2,-3,4,10,14) # find all elements of my.x where my.y is higher than 0 my.piece.x &lt;- my.x[ my.y &gt; 0 ] # print it print(my.piece.x) ## [1] 6 8 12 Looking more closely at the indexing process, it is worth noting that, when we use a data indexing condition, we are in fact creating a variable of the logical type. This object takes only two values: TRUE and FALSE. Have a look in the code presented next, where we create a logical object, print it and present its class. # create a logical object my.logical &lt;- my.y &gt; 0 # print it print(my.logical) ## [1] FALSE FALSE TRUE TRUE TRUE # find its class class(my.logical) ## [1] &quot;logical&quot; 2.14 Removing Objects from the Memory After creating several variables, the R environment can become full of content that’s already been used and is dispensable. In this case, it is desirable to clear the memory to erase objects that are no longer needed. Generally, this is accomplished at the beginning of a script, so that every time the script runs, the memory will be cleared before any calculation. In addition to cleaning the computer’s memory, it also helps to avoid possible errors in the code. In most cases, cleaning the working environment should be performed only once at the beginning of the script. For example, given an object x, we can delete it from memory with the command rm, as shown next: # set x x &lt;- 1 # print all available objects ls() ## [1] &quot;elem.x&quot; &quot;M&quot; &quot;my.array&quot; ## [4] &quot;my.char&quot; &quot;my.dim&quot; &quot;my.engine&quot; ## [7] &quot;my.fct&quot; &quot;my.length&quot; &quot;my.logical&quot; ## [10] &quot;my.ncol&quot; &quot;my.nrow&quot; &quot;my.out.width&quot; ## [13] &quot;my.piece.x&quot; &quot;my.str&quot; &quot;my.text&quot; ## [16] &quot;my.text.1&quot; &quot;my.text.2&quot; &quot;my.text.3&quot; ## [19] &quot;my.vec&quot; &quot;my.x&quot; &quot;my.y&quot; ## [22] &quot;my.z&quot; &quot;n&quot; &quot;piece.x.1&quot; ## [25] &quot;piece.x.2&quot; &quot;piece.x.3&quot; &quot;piece.x.4&quot; ## [28] &quot;stay.quiet&quot; &quot;x&quot; &quot;y&quot; ## [31] &quot;z&quot; # remove x rm(&#39;x&#39;) # print again all available objects ls() ## [1] &quot;elem.x&quot; &quot;M&quot; &quot;my.array&quot; ## [4] &quot;my.char&quot; &quot;my.dim&quot; &quot;my.engine&quot; ## [7] &quot;my.fct&quot; &quot;my.length&quot; &quot;my.logical&quot; ## [10] &quot;my.ncol&quot; &quot;my.nrow&quot; &quot;my.out.width&quot; ## [13] &quot;my.piece.x&quot; &quot;my.str&quot; &quot;my.text&quot; ## [16] &quot;my.text.1&quot; &quot;my.text.2&quot; &quot;my.text.3&quot; ## [19] &quot;my.vec&quot; &quot;my.x&quot; &quot;my.y&quot; ## [22] &quot;my.z&quot; &quot;n&quot; &quot;piece.x.1&quot; ## [25] &quot;piece.x.2&quot; &quot;piece.x.3&quot; &quot;piece.x.4&quot; ## [28] &quot;stay.quiet&quot; &quot;y&quot; &quot;z&quot; Note that after executing the command rm('x'), the value of x is no longer available in the output of ls(). In practical situations, however, it is desirable to clean up all the memory used by all objects created in R. We can achieve this goal with the following code: rm(list=ls()) The term list in rm(list=ls()) is a function argument of rm that defines which objects will be deleted. The ls() command shows all the currently available objects. Therefore, by chaining together both commands, we erase all current objects available in the environment. As mentioned before, it is good programming policy to always start the script by clearing the memory. However, you should only wipe out all of R’s memory if you have already saved the results of interest or if you can replicate them. 2.15 Displaying and Setting the Working Directory Like other programming platforms, R always works in a directory. If no directory is set, a default value is used when R starts up. It is based on the current directory that R searches for files to load data or other R scripts. It is in this directory that R saves any output we want if we do not explicitly define an address on the computer. This output can be a graphic file, text or a spreadsheet like file. A good programming policy is to change the working directory to the same place where the script is located. In chapter ?? we discuss the topic of file and folder organization. To show the current working directory, use function getwd: # get current dir my.dir &lt;- getwd() # display it print(my.dir) ## [1] &quot;C:/Dropbox/My Books/pmfdR (en)/Book Content&quot; The result of the previous code shows the folder in which this book was written and compiled. As you can see, the book files are saved in a subfolder of my Dropbox directory. From the path, you should also realize that I’m working in a Windows OS. The root directory C:/ gives that information away. The change of working directory is performed with the setwd command. For example, if we wanted to change our working directory to C:/My Research/, simply type in the prompt: # set where to change directory my.d &lt;- &#39;C:/My Research/&#39; # change it setwd(my.d) As for simple cases such as the above, remembering the directory name is easy. In practical cases, however, the working directory can be in a deeper directory of the file system. In this situation, an efficient strategy to locate the path is to use a file explorer, like Windows explorer. To do so, open the explorer application and navigate to the location where you want to work with your script. Place the cursor in the address bar and select the whole path. Press control + c to copy the address to the clipboard. Go back to your code and paste it in. An important step here: Windows uses the backslash to set addresses on the computer, while the R uses the forward slash. If you try to use backslashes, an error is displayed on the screen. See the following example. # set directory (WRONG WAY) my.d &lt;- &#39;C:\\My Research\\&#39; cat(&quot;##Error: &#39;\\\\M&#39; is an unrecognized escape in character string&quot;) This message means that R was not able to understand the use of backslashes. This is a reserved symbol for macros and should not be used anywhere in a code. Therefore, after copying the address, modify all backslashes to forward slashes, as in the following code: # set directory (CORRECT WAY) my.d &lt;- &#39;C:/My Research/&#39; # change dir setwd(my.d) You can also use double backslashes \\\\ but this is not recommended as it is not compatible with other operating systems. Another important information here is that you can also use relative paths. For example, if you are working in a folder that contains a subdirectory called Data, you can enter this subfolder with the code: # change to subfolder setwd(&#39;Data&#39;) Another possibility is to go to a previous level of directory using .., as in: # change to previous level setwd(&#39;..&#39;) So, if you are working in the directory C:/My Research/ and execute the command setwd('..'), the current folder becomes C:/, which is one level above C:/My Research/. Another, more modern, way of setting the directory is to use RStudio API functions. This is a set of functions that only work inside RStudio and provides information about current file, project and many more. To find out the path of the current R script being edited in RStudio and set the working directory to there, you can write: my.path &lt;- dirname(rstudioapi::getActiveDocumentContext()$path) setwd(my.path) This way, the script will change the directory to its own location, no matter where you copy it. Be aware, however, that this trick only works in RStudio script editor and within a saved file. It will not work from the prompt. 2.16 Cancelling Code Execution Whenever R is running some code, a visual cue in the shape of a small red circle in the right corner of the prompt will appear. If you read it, the text shows the stop word. This button is not only an indicator for running code but also a shortcut for cancelling its execution. Another way to cancel an execution is to point the mouse to the prompt and press the escape (esc) button from the keyboard. To try it out, run the next chunk of code in RStudio and cancel its execution using esc. for (i in 1:100) { cat(&#39;\\nRunning code (please make it stop by hitting esc!)&#39;) Sys.sleep(1) } In the previous code, we used a for loop to display the message '\\nRunning code (please make it stop by hitting esc!)' every second. For now, do not worry about the code and functions used in the example. We will discuss the use of loops chapter ??. 2.17 Code Comments In R, comments are set using the hash tag symbol #. Anything after this symbol will not be processed by R. This gives you freedom to write whatever you want within the script. An example: # this is a comment (R will not parse it) # this is another comment (R will not parse it) x &lt;- &#39;abc&#39; # this is an inline comment Comments are a way to communicate any important information that cannot be directly inferred from the code. In general, you should avoid using comments that are too obvious or too generic. For example: # read csv file df &lt;- read.csv(&#39;MyDataFile.csv&#39;) As you can see, it is quite obvious from line df &lt;- read.csv('MyDataFile.csv) that the code is reading a .csv file. The name of the function already states that. So, the comment was not a good one as it did not add any new information to the user. A better approach at commenting would be to set the author, description of script and better explain the origin and last update of the data file. Have a look: # Script for analysing a dataset # Author: Mr data analyst (dontspamme@emailprovider.com) # Last script update: 2017-03-10 # # File downloaded from www.sitewithdatafiles.com/data-files/ # The description of the data goes here # Last file update: 2017-03-10 df &lt;- read.csv(&#39;MyDataFile.csv&#39;) So, by reading the comments, the user will know the purpose of the script, who wrote it and the date of the last edit. It also includes the origin of the data file and the date of the latest update. If the user wants to update the data, all he has to do is to go to the referred website and download the new file. If the datafile is updated, a new date should be placed in “Last file update”. Another use of comments is to set sections in the code, such as in: # Script for analysing a dataset # Author: Mr data analyst (dontspamme@emailprovider.com) # Last script update: 2017-03-10 # # File downloaded from www.sitewithdatafiles.com/data-files/ # The description of the data goes here # Last file update: 2017-03-10 ... # Clean data # - remove outliers # - remove unnecessary columns ... # Report results # - remove outliers # - remove unnecessary columns ... This way, once you need to change a particular part of the code, you can look for the related section in the comments. If you share code with other people, you’ll soon realize that comments are essential and expected. They help transmit information that is not available from the code. A note here, throughout the book you’ll see that the code comments are, most of the time, a bit obvious. This was intentional as clear and direct messages are important for new users, which is part of the audience of this book. 2.18 Looking for Help A common task in the use of R is to seek help. Even advanced users often seek instructions on specific tasks, whether it is to better understand the details of some functions or simply to study a new procedure. The use of the R help system is part of everyday routine with the software. You can get help by using the help panel in RStudio or directly from the prompt. Simply enter the question mark next to the object on which you want help, as in ?mean. In this case, object mean is a function and the use of the help command will open a panel on the right side of RStudio. In R, the help screen of a function is the same as shown in Figure 2.6. It presents a general description of the function, explains its input arguments and the format of the output. The help screen follows with references and suggestions for other related functions. More importantly, examples of usage are given last and can be copied to the prompt or script in order to accelerate the learning process. Figure 2.6: Help screen for function mean If we are looking for help for a given text and not a function name, we can use double question marks as in ??&quot;standard deviation&quot;. This operation will search for the occurrence of the term in all packages of R and it is very useful to learn how to perform a particular task. In this case, we looked for the available functions to calculate the standard deviation of a vector. As a suggestion of usage, the easiest and most direct way to learn a new function is trying out the examples in the manual. This way, you can see which type of input objects the function expects and what type of output it gives. Once you have it working, read the help screen to understand if it does exactly what you expected and what are the options for its use. If the function performs the desired procedure, you can copy and paste the code example for your own script, adjusting where necessary. Another very important source of help is the Internet itself. Sites like stackoverflow and specific mailing lists, whose content is also on the Internet, are a valuable source of information. If you find a problem that could not be solved by reading the standard help files, the next logical step is to seek a solution using your error message or the description of the problem in search engines. In many cases, your problem, no matter how specific it is, has already occurred and has been solved by other users. In fact, it is more surprising not to find the solution for a programming problem on the internet, than the other way around. 2.19 R Packages One of the greatest benefits of using R is its package collection. A package is nothing more than a group of procedures aimed at solving a particular computational problem. R has at its core a collaborative philosophy. Users provide their codes for others to use. And, most importantly, all packages are free. For example, consider a case where the user is interested in accessing data about historical inflation in the USA. He can install and use a R package that is specifically designed for importing economic statistics for a country. Every function in R belongs to a package. When R initializes, packages stats, graphics, grDevices, utils, datasets, methods and base are loaded by default. Almost every function we have used so far belongs to the package base. R packages can be accessed and installed from different sources. The main being CRAN (The Comprehensive R Archive network), R-Forge and Github. The quantity and diversity of R packages increases every day. At the time of the publication of this book, the author of this book has six packages available on CRAN: GetHFData - Allows direct access to high frequency financial transaction data from Bovespa (Brazilian Financial Exchange); GetTDData - Enables access to prices and yields of bonds issued by the Brazilian government; RndTexExams - Enables the creation and correction of single choice exams with randomized content; BatchGetSymbols - Package for easy access to daily data from Yahoo! Finance and Google Finance; Predatory - Package to identify predatory journals based on the Beall site data; pmfdR - Provides code, data and exercises for this book. CRAN is the official repository of R and it is built by the community. Anyone can send a package. However, there is an evaluation process to ensure that the certain strict rules about code format are respected. For those interested in creating and distributing packages, a clear and easy to learn material on how to create and send packages to CRAN is presented on the site R packages. Complete rules are available on the CRAN website. The suitability of the code to CRAN standards is the developer’s responsibility. By personal experience, sending and publishing a package on CRAN demands a significant amount of work, especially in the first submission. After that, it becomes a lot easier. Don’t be angry if you package is rejected. My own packages were rejected several times before entering CRAN. Listen to what the maintainers tell you and try fixing all problems before resubmitting. If you’re having issues that you cannot solve or find a solution in the Internet, look for help in the R-packages mailing list. You’ll be surprised at how accessible and helpful the R community can be. The complete list of packages available on CRAN, along with a brief description, can be accessed at the packages link on the R site. A practical way to check if there is a package that does a specific procedure is to load the previous page and search in your browser for a keyword. If there is a package that does what you want, it is very likely that the keyword is used in the description of the package. Another important source for finding packages is Task Views. There you can find the most important packages for a given area of expertise. See the Task Views screen in Figure 2.7. Figure 2.7: Task View screen Unlike CRAN, R-Forge and Github have no restriction on the code sent to their repository and, because of this, these repositories tend to be chosen by developers. Responsibility in the use, however, is with the user. In practice, it is very common for developers to maintain a development version on Github or R-Forge and the official version in CRAN. When the development version reaches a certain stage of maturity, it is then sent to CRAN. The most interesting part of this is that the packages can be accessed and installed directly from the prompt using the internet. To find out the current amount of packages on CRAN, type and execute the following commands in the prompt: # get matrix with available packages df.cran.pkgs &lt;- available.packages() # find the number of packages n.cran.packages &lt;- nrow(df.cran.pkgs) # print it print(n.cran.packages) ## [1] 10458 If asked about which mirror to use, simply select the one closest to you. Currently (2017-04-29 13:02:19), there are 10458 packages available on the CRAN servers. We can see some details of the first three packages in df.cran.pkgs with function print and some indexing: # print information about the first three packages print(df.cran.pkgs[1:3, ]) ## Package Version Priority ## A3 &quot;A3&quot; &quot;1.0.0&quot; NA ## abbyyR &quot;abbyyR&quot; &quot;0.5.1&quot; NA ## abc &quot;abc&quot; &quot;2.1&quot; NA ## Depends ## A3 &quot;R (&gt;= 2.15.0), xtable, pbapply&quot; ## abbyyR &quot;R (&gt;= 3.2.0)&quot; ## abc &quot;R (&gt;= 2.10), abc.data, nnet, quantreg, MASS, locfit&quot; ## Imports LinkingTo ## A3 NA NA ## abbyyR &quot;httr, XML, curl, readr, plyr, progress&quot; NA ## abc NA NA ## Suggests Enhances ## A3 &quot;randomForest, e1071&quot; NA ## abbyyR &quot;testthat, rmarkdown, knitr (&gt;= 1.11)&quot; NA ## abc NA NA ## License License_is_FOSS ## A3 &quot;GPL (&gt;= 2)&quot; NA ## abbyyR &quot;MIT + file LICENSE&quot; NA ## abc &quot;GPL (&gt;= 3)&quot; NA ## License_restricts_use OS_type Archs MD5sum ## A3 NA NA NA NA ## abbyyR NA NA NA NA ## abc NA NA NA NA ## NeedsCompilation File ## A3 &quot;no&quot; NA ## abbyyR &quot;no&quot; NA ## abc &quot;no&quot; NA ## Repository ## A3 &quot;https://cloud.r-project.org/src/contrib&quot; ## abbyyR &quot;https://cloud.r-project.org/src/contrib&quot; ## abc &quot;https://cloud.r-project.org/src/contrib&quot; In short, object df.cran.pkgs displays the names of packages, its current version, its dependencies, along with various other information. You can also check the amount of locally installed packages in R with the installed.packages command: # find number of packages currently installed n.local.packages &lt;- nrow(installed.packages()) # print it print(n.local.packages) ## [1] 358 In this case, the computer on which the book was written has 358 packages currently installed. This value is probably different from yours. Give it a try! 2.19.1 Installing Packages from CRAN To install a package, simply use the command install.packages. You only need to do it once for each new package. As an example, we will install a package called quantmod that will be used in future chapters. # install package quantmod install.packages(&quot;quantmod&quot;) That’s it! After executing this simple command, package quantmod and all of its dependencies will be installed and the functions related to the package will be ready for use once the package is loaded in a script. Note that we defined the package name in the installation as if it were text with the use of quotation marks (&quot; &quot;). If the installed package is dependent on another package, R detects this dependency and automatically installs the missing packages. Thus, all the requirements for using the installed package will already be satisfied and everything will work perfectly. It is possible, however, that a package has an external dependency. As an example, package RndTexExams depends on the existence of a LaTeX installation. These cases are usually announced in the description of the package and an error informs that a requirement is missing. External dependencies for R packages are not common, but they do happen. 2.19.2 Installing Packages from Github To install a package hosted in Github, you must install the devtools package, available on CRAN: # install devtools install.packages(&#39;devtools&#39;) After that, load up the package devtools and use the function install_github to install a package directly from Github. In the following example, we install the development version of the package ggplot2, whose official version is also available at CRAN: # load up devtools library(devtools) # install ggplot2 from github install_github(&quot;hadley/ggplot2&quot;) Note that the username of the developer is also included. In this case, the hadley name belongs to the developer of ggplot2, Hadley Wickham. Throughout the book, you will notice that this name appears several times. Hadley is a prolific and competent developer of several R packages and currently works for RStudio. 2.19.3 Loading Packages Within a script, use function library to load a package, as in the following example. # load package quantmod library(quantmod) After running this command, all functions of the package will be available to the user. In this case, it is not necessary to use &quot; &quot; to load the package. If the package you want to use is not available, R will throw an error message. See an example next, where we try to load a non-existing package called unicorn. library(unicorn) ## Error in library(unicorn): there is no package called &#39;unicorn&#39; Remember this error message. It will appear every time a package is not found. If you got the same message when running code from this book, you need to check what are the required packages of the example and install them using install.packages, as in install.packages('unicorn'). If you use a specific package function and do not want to load all functions from the package, you can do it through the special symbol ::, as in the following example. # example of using a function without loading package fortunes::fortune(10) ## ## Overall, SAS is about 11 years behind R and S-Plus in ## statistical capabilities (last year it was about 10 years ## behind) in my estimation. ## -- Frank Harrell (SAS User, 1969-1991) ## R-help (September 2003) In this case, we use the function fortune from the package fortunes, which shows on screen a potentially funny phrase chosen from the R mailing list. For our example, we selected message number 10. One interesting use of the package fortune is to display a different message every time R starts. As mentioned before, you can find many tutorials on how to achieve this effect by searching on the web for “customizing R startup”. Another way of loading a package is using the require function. A call to require has a different behaviour than a call to library. When using library, if the package is not found in the local libraries, it returns an error. This means that the script stops and no further code is evaluated. As for require, if a package is not found, it returns an object with value FALSE and the rest of the code is evaluated. So, in order to avoid code being executed without its explicit dependencies, it is advised to always use library for loading package in scripts. The use of require is left for loading up packages inside of functions. If you create a custom function that requires procedures from a particular package, you must load the package within the scope of the function. For example, see the following code, where we create a new function called my.fct that depends on the package quantmod: my.fct &lt;- function(x){ require(quantmod) df &lt;- getSymbols(x, auto.assign = F) return(df) } In this case, the first time that my.fct is called, it loads up the package quantmod and all of its functions. Using require inside a function is good programming policy because the function becomes self contained, making it easier to use it in the future. This was the first time where the complete definition of a function in R is presented. Do not worry about it now. We will explain it further in chapter ??. 2.19.4 Upgrading Packages Over time, it is natural that the packages available on CRAN are upgraded to accommodate new features, correct bugs and adapt to changes. Thus, it is recommended that users update their installed packages to a new version over the internet. In R, this procedure is quite easy. A direct way of upgrading packages is to click the button update located in the package panel, lower right corner of RStudio, as shown in Figure 2.8. Figure 2.8: Updating R packages The user can also update packages through the prompt. Simply type command update.packages() and hit enter, as shown below. # update all installed packages update.packages() The command update.packages compares the version of the installed packages with the versions available in CRAN. If it finds any difference, the new versions are downloaded and installed. After running the command, all packages will be synchronized with the versions available in CRAN. 2.20 Using Code Completion with tab A very useful feature of Studio is code completion. This is an editing tool that facilitates the search of names for objects, packages, function arguments and files. Its usage is very simple. After you type any first character, just press the tab (left side of keyboard, above capslock) and a number of options will appear. See Figure 2.9 where, after entering the f letter and pressing tab, a window appears with a list of object names that begins with that letter. Figure 2.9: Usage of autocomplete for object name This also works for packages. To check it, type library(r) in the prompt or editor, place the cursor in between the parentheses and press tab. The result should look something like Figure 2.10, shown next. Figure 2.10: Usage of autocomplete for packages Note that a description of the package or object is also offered by the code completion tool. This greatly facilitates the day to day work as the memorization of package names and R objects is not an easy task. The use of the tab decreases the time to look up names, also avoiding possible coding errors. The use of this tool becomes even more beneficial when objects and functions are named with some sort of pattern. In the rest of the book, you will notice that objects tend to be named with the prefix my., as my.x, my.num. Using this naming rule (or any other) facilitates the lookup for names of objects created by the user. You can just type my., press tab, and a list of all objects previously created by the user will appear. You can also find files and folders on your computer using tab. To try it, write the command my.file &lt;- &quot;&quot; in the prompt or a script, point the cursor to the middle of the quotes and press the tab key. A screen with the files and folders from the current working directory should appear, as shown in Figure 2.11. You can use the keyboard arrow keys to navigate. Figure 2.11: Usage of autocomplete for files and folders The use of autocomplete is also possible for finding the name and description of function arguments. To try it out, write cat() and place the mouse cursor inside the parentheses. After that, press tab. The result should be similar to Figure 2.12. Figure 2.12: Usage of autocomplete for function arguments By using tab inside of a function, we have the names of all arguments and their description. This is the same information found in the help files. Summing up, using code completion will make you more productive. You’ll find names of files, objects, arguments and packages much faster. Use it whenever possible. 2.21 Interacting with Files and the Operating System In many data analysis situations, it will be necessary to interact with files in the computer, either by creating new folders, decompressing and compressing files, listing and removing files from the hard drive of the computer or any other type of operation. In most cases, R will interact with files containing data. 2.21.1 Listing Files and Folders To list files from your computer, use function list.files, where the path argument sets the directory to list the files from. For the compilation of the book, I’ve created a directory called data. This folder contains all the data needed to recreate the book’s examples. You can check the files in the subfolder data with the following code: # list files in data folder my.f &lt;- list.files(path = &quot;data&quot;, full.names = TRUE) print(my.f) ## [1] &quot;data/AdjustedPrices-InternacionalIndices.RDATA&quot; ## [2] &quot;data/BovStocks_2011-12-01_2016-11-29.csv&quot; ## [3] &quot;data/BovStocks_2011-12-01_2016-11-29.RData&quot; ## [4] &quot;data/example_gethfdata.RDATA&quot; ## [5] &quot;data/FileWithLatinChar.txt&quot; ## [6] &quot;data/grunfeld.csv&quot; ## [7] &quot;data/HFData.csv&quot; ## [8] &quot;data/HFData_6_Assets_15 min.RData&quot; ## [9] &quot;data/MktIndices_and_Symbols.csv&quot; ## [10] &quot;data/MySQLiteDatabase.SQLITE&quot; ## [11] &quot;data/SP500-Excel.xlsx&quot; ## [12] &quot;data/SP500-Stocks-WithRet.RData&quot; ## [13] &quot;data/SP500-Stocks_long.csv&quot; ## [14] &quot;data/SP500-Stocks_wide.csv&quot; ## [15] &quot;data/SP500.csv&quot; ## [16] &quot;data/SP500_2011-11-13_2016-11-11.csv&quot; ## [17] &quot;data/TDData.csv&quot; ## [18] &quot;data/temp.csv&quot; ## [19] &quot;data/temp.RData&quot; ## [20] &quot;data/temp.txt&quot; ## [21] &quot;data/temp.xlsx&quot; ## [22] &quot;data/temp_xts.RData&quot; Note that in this directory, there are several files with different extensions. These files contain data that will be used in future chapters. When using list.files, it is recommended to set input full.names as TRUE. This option makes sure that the names returned by the function contains the full path of the found files. This facilitates further manipulation, such as reading and importing information from data files. It is worth noting that you can also list the files recursively, that is, list all files from all subfolders contained in the original address. To check it, try using the following code in your computer: # list all files for all subfolders (IT MAY TAKE SOME TIME...) list.files(path = getwd(), recursive = T, full.names = TRUE) The previous command will list all files in the current folder and subfolders. Depending on the current working directory, it may take some time to run it all. If you executed it, be patient or just cancel it pressing esc. To list folders (directories) on your computer, use the command list.dirs. See below. # store names of directories my.dirs &lt;- list.dirs(recursive = F) # print it print(my.dirs) ## [1] &quot;./.Rproj.user&quot; ## [2] &quot;./_book&quot; ## [3] &quot;./_bookdown_files&quot; ## [4] &quot;./data&quot; ## [5] &quot;./docs&quot; ## [6] &quot;./eqs&quot; ## [7] &quot;./fig_ggplot&quot; ## [8] &quot;./figs&quot; ## [9] &quot;./ftp files&quot; ## [10] &quot;./latex_files&quot; ## [11] &quot;./many_datafiles&quot; ## [12] &quot;./ProcAnFinDataR_ed_1_cache&quot; ## [13] &quot;./ProcAnFinDataR_ed_1_files&quot; ## [14] &quot;./procmodelfindatar_ed_1_cache&quot; ## [15] &quot;./procmodelfindatar_ed_1_files&quot; ## [16] &quot;./Removed chapters&quot; ## [17] &quot;./Scripts&quot; ## [18] &quot;./tabs&quot; The command list.dirs(recursive = F) listed all directories of the current path without recursion. The output shows the directories that I have used to write this book. It includes the output directory of the book ( ./_book), the directory with the data (./data), among others. In this same directory, you can find the chapters of the book, organized by files and based on the RMarkdown language (.Rmd file extension). To list only files with the extension .Rmd, we can use the pattern input in function list.files as follows: # list all files with extension .Rmd list.files(pattern = &quot;*.Rmd&quot;) ## [1] &quot;_Welcome.Rmd&quot; ## [2] &quot;00-Preface.Rmd&quot; ## [3] &quot;01-Introduction.Rmd&quot; ## [4] &quot;02-BasicOperations.Rmd&quot; ## [5] &quot;03-BasicObjects.Rmd&quot; ## [6] &quot;04-DataStructureObjects.Rmd&quot; ## [7] &quot;05-Financial-data-and-common-operations.Rmd&quot; ## [8] &quot;06-ImportingExporting.Rmd&quot; ## [9] &quot;07-Programming.Rmd&quot; ## [10] &quot;08-Figures.Rmd&quot; ## [11] &quot;09-Models.Rmd&quot; ## [12] &quot;10-ResearchScripts.Rmd&quot; ## [13] &quot;11-references.Rmd&quot; ## [14] &quot;index.Rmd&quot; ## [15] &quot;ProcAnFinDataR_ed_1.Rmd&quot; The files presented above contain all the contents of this book, including this specific paragraph, located in file 02-BasicOperations.Rmd! "]
]
